## Orwell Spark v3 使用指南 

### 一、程序介绍

Orwell Spark 是一个使用 Google 公司推出的 **Go 语言** 编写的，部分灵感来自于常用密码学工具 GnuPG 的，用来作为**星火杯**创意项目 demo 的一个**轻量**、**跨平台**实现。它是一个支持 RSA 密钥对**生成**，**签名**，**验签**，**加密**，**解密** 的命令行工具，同时支持**多文件**统一签名。其中加密和解密功能在是 v3 版本中首次加入的特性。

### 二、使用方法

以在 **Linux** 的 **shell** 中运行程序为例，**Windows** 可使用 **命令提示符** 或 **Powershell** 。

#### (一) 生成密钥对

您可以使用命令 `gen` 进行密钥对的生成，它有一个可选参数 `-k` ，用来指定输出密钥对的文件名，如果不指定，默认名称为 `key` 

```shell
$ spark3 gen
```

这样就在当前目录产生了公钥文件 `key.pub` 和对应的私钥文件 `key.scrkey` 。

 ```shell
$ spark3 gen -k "rsa_key"
 ```

这样就在当前目录产生了公钥文件 `rsa_key.pub` 和对应的私钥文件 `rsa_key.scrkey` 。

#### (二) 签名与验签

##### 2. 文件签名

您可以使用命令 `sign` 进行文件签名，它有三个参数， `-f` 用来指定待签名的文件； `-k` 用来指定签名使用的私钥；`-o` 用来指定输出的签名文件名，可以缺省。

注意 `-f`  用来可以指定多个文件，此时必须整体写在双引号内，且不同文件名以空格分隔；`-k` 指定的私钥文件名必须以 `.scrkey` 结尾，且输入内容不含该后缀。与以往工具不同的是，该程序生成的签名文件内容并不是字节集，而是以 Base64 编码后的文本，便于传输与查看。

例如现在有文件 `key01.pub` `file01.txt` `file02.c` `key01.scrkey`，如果我们想使用私钥 `key01.scrkey` 对 `file01.txt` `file02.c` 进行合并签名，可以使用如下命令：

```shell
$ spark3 sign -f "file01.txt file02.c" -k "key01" -o "mysign.sgn"
```

这样就使用私钥 `key01.scrkey`  将两个文件进行了合并签名，签名结果以 Base64 编码保存在了 `mysign.sgn` 文件中。

其中`-o` 参数可以不写，例如：

```shell
$ spark3 sign -f "file01.txt" -k "key01"
```

这样就使用私钥 `key01.scrkey`  对文件 `file01.txt` 进行了签名，结果默认保存在 `ok.sgn` 中。

提示：指定参数时 `-f`，`-k` ，`-o`，三个参数的顺序可以交换。

##### 3. 验证签名

您可以使用命令 `verify` 进行签名的验证，它有三个参数， `-f` 用来指定被签名的文件； `-k` 用来指定验证签名需要的公钥；`-s` 用来指定签名文件。

我们以上文签名时产生的 `mysign.sgn` 为例，输入以下指令：

```shell
$ spark3 verify -f "file01.txt file02.c" -k "key01" -s "mysign.sgn"
```

这样就使用公钥 `key01.pub` 对签名 `mysign.sgn` 进行了合并验证，如果验证成功，将会提示：

```ini
Signature verified successfully.
```

如果失败，将会具体指出失败原因，例如签名验证失败时，将会提示：

```ini
Signature verification failed: crypto/rsa: verification error
```

如果找不到相应文件，将会提示：

```ini
Failed to read file: open <file>: The system cannot find the file specified.
```

我们还支持了更多可能遇到的错误情形，这里不再列举。

值得注意的是，我们的多文件签名验证要求您的 `-f` 指定的文件名的顺序必须与签名时输入的**顺序相同**，否则也会无法通过签名验证。这是因为多文件签名时，我们采用的方案为先将输入的所有文件以二进制流的形式读入内存，再在内存中按顺序进行拼接，最后对二进制流的整体进行签名。因为考虑到星火杯的**实际需求**，如果内容签名验证如果涉及多文件，先打包再签名就会导致在传递的过程中出现层层打包嵌套的情况。我们这样做，可以避开打包嵌套的尴尬，更方便实际使用。

#### (三) 加密与解密

鉴于 **签名与验签** 部分的说明已经足够详细，**加密与解密** 部分基本类似，不再详细说明，仅提供以下示例。

##### 4. 文件加密

您可以使用命令 `encode` 进行文件加密，它有三个参数， `-f` 用来指定待加密的文件； `-k` 用来指定加密使用的公钥；`-o` 用来指定加密后文件的文件名。

我们以公钥 `key01.pub` 为例，输入以下指令：

```shell
$ spark3 -f "file01.txt" -k "key01" -o "f1.enc"
```

这样就使用公钥 `key01.pub` 对文件 `file01.txt` 进行加密，保存为文件 `f1.enc` 。

如果不指定 `-o` 参数，默认为 `encrypted` 。

##### 5. 文件解密

您可以使用命令 `decode` 进行文件解密，它有三个参数， `-f` 用来指定待解密的文件； `-k` 用来指定解密使用的私钥；`-o` 用来指定解密后的文件名。

我们以私钥 `key01.scrkey` 为例，输入以下指令：

```shell
$ spark3 -f "f1.enc" -k "key01" -o "f1.txt"
```

这样就使用私钥 `key01.scrkey` 对密文文件 `f1.enc` 进行了解密，导出到文件 `f1.txt` 。

如果不指定 `-o` 参数，默认为 `decrypted` 。

### 三、后续更新

1. 相对于 v2 版本，加密与解密已经实现。
2. 目前可能的更新有
   1. 与目前已经测试成型的后端程序结合，程序自身提供平台中介，该方向已提上日程。
   2. 在 1 的基础上提供移动端平台支持，目前已经在移动端实现简易的 http 应用。
   3. 支持选择多种公钥算法。
   4. 将公钥算法改作插件形式，支持使用者自定义算法。

