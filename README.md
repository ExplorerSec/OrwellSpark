# Orwell Spark 2.0 使用指南 

### 一、程序介绍

Orwell Spark 是一个使用 Google 公司推出的 **Go 语言** 编写的，部分灵感来自于常用密码学工具 GnuPG 的，用来作为**星火杯**创意项目 demo 的一个**轻量**、**跨平台**实现。它是一个支持 RSA 密钥对**生成**，**签名**和**验签**的命令行工具，同时支持**多文件**统一签名。

### 二、使用方法

以在 **Linux** 的 **shell** 中运行程序为例，**Windows** 可使用 **命令提示符** 或 **Powershell** 。

#### 1. 生成密钥对

您可以使用命令 `gen` 进行密钥对的生成，它有一个可选参数 `-k` ，用来指定输出密钥对的文件名，如果不指定，默认名称为 `key` 

```shell
$ spark2 gen
```

这样就在当前目录产生了公钥文件 `key.pub` 和对应的私钥文件 `key.scrkey` 。

 ```shell
$ spark2 gen -k "rsa_key"
 ```

这样就在当前目录产生了公钥文件 `rsa_key.pub` 和对应的私钥文件 `rsa_key.scrkey` 。

#### 2. 签名文件

您可以使用命令 `sign` 进行文件签名，它有三个参数， `-f` 用来指定待签名的文件； `-k` 用来指定签名使用的私钥；`-o` 用来指定输出的签名文件名，可以缺省。

注意 `-f`  用来可以指定多个文件，此时必须整体写在双引号内，且不同文件名以空格分隔；`-k` 指定的私钥文件名必须以 `.scrkey` 结尾，且输入内容不含该后缀。与以往工具不同的是，该程序生成的签名文件内容并不是字节集，而是以 Base64 编码后的文本，便于传输与查看。

例如现在有文件 `key01.pub` `file01.txt` `file02.c` `key01.scrkey`，如果我们想使用私钥 `key01.scrkey` 对 `file01.txt` `file02.c` 进行合并签名，可以使用如下命令：

```shell
$ spark2 sign -f "file01.txt file02.c" -k "key01" -o "mysign.sgn"
```

这样就使用私钥 `key01.scrkey`  将两个文件进行了合并签名，签名结果以 Base64 编码保存在了 `mysign.sgn` 文件中。

其中`-o` 参数可以不写，例如：

```shell
$ spark2 sign -f "file01.txt" -k "key01"
```

这样就使用私钥 `key01.scrkey`  对文件 `file01.txt` 进行了签名，结果默认保存在 `ok.sgn` 中。

提示：指定参数时 `-f`，`-k` ，`-o`，三个参数的顺序可以交换。

#### 3. 验证签名

您可以使用命令 `verify` 进行签名的验证，它有三个参数， `-f` 用来指定被签名的文件； `-k` 用来指定验证签名需要的公钥；`-s` 用来指定签名文件。

我们以上文签名时产生的 `mysign.sgn` 为例，输入以下指令：

```shell
$ spark2 verify -f "file01.txt file02.c" -k "key01" -s "mysign.sgn"
```

这样就使用公钥 `key01.pub` 对签名 `mysign.sgn` 进行了合并验证，如果验证成功，将会提示：

```ini
Signature verified successfully.
```

如果失败，将会具体指出失败原因，例如签名验证失败时，将会提示：

```ini
Signature verification failed: crypto/rsa: verification error
```

如果找不到相应文件，将会提示：

```ini
Failed to read file: open <file>: The system cannot find the file specified.
```

我们还支持了更多可能遇到的错误情形，这里不再列举。

值得注意的是，我们的多文件验证要求您的 `-f` 指定的文件名的顺序必须与签名时输入的**顺序相同**，否则也会无法通过签名验证。这是因为多文件签名时，我们采用的方案为先将输入的所有文件以二进制流的形式读入内存，再在内存中按顺序进行拼接，最后对二进制流的整体进行签名。因为考虑到星火杯的**实际需求**，如果内容签名验证如果涉及多文件，先打包再签名就会导致在传递的过程中出现层层打包嵌套的情况。我们这样做，可以避开打包嵌套的尴尬，更方便实际使用。

### 三、后续更新

1. 后续的更新已确定有非对称的加密和解密。

2. 可能的更新有
   1. 与目前已经基本测试成型的后端程序结合，程序自身提供平台中介。
   2. 支持选择多种算法。
   3. 将公钥算法改作插件形式，支持使用者自定义算法。

